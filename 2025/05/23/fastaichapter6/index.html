<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="其他计算机视觉问题上一章学习了实践中训练模型的一些基本技术，例如：学习率和周期律的选择。这一章我们需要深入学习其他两种机器视觉问题。  多标签分类：发生在你想要预测每个图像的多个标签（有时甚至没有标签）  回归： 你的标签是一个或多个数字——数量而不是类别。   这需要深入学习：输出激活，目标和损失函数。 多标签分类多标签分类指的是识别图像中可能不只包含一种对象类别的问题。可能有多种对象，或者在你">
<meta property="og:type" content="article">
<meta property="og:title" content="fastaichapter6">
<meta property="og:url" content="http://example.com/2025/05/23/fastaichapter6/index.html">
<meta property="og:site_name" content="WangSong&#39;s blog">
<meta property="og:description" content="其他计算机视觉问题上一章学习了实践中训练模型的一些基本技术，例如：学习率和周期律的选择。这一章我们需要深入学习其他两种机器视觉问题。  多标签分类：发生在你想要预测每个图像的多个标签（有时甚至没有标签）  回归： 你的标签是一个或多个数字——数量而不是类别。   这需要深入学习：输出激活，目标和损失函数。 多标签分类多标签分类指的是识别图像中可能不只包含一种对象类别的问题。可能有多种对象，或者在你">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/dlcf_06in01.png">
<meta property="og:image" content="http://example.com/image/dlcf_06in02.png">
<meta property="og:image" content="http://example.com/image/dlcf_06in03.png">
<meta property="og:image" content="http://example.com/2025/05/23/fastaichapter6/img/dlcf_06in04.png">
<meta property="og:image" content="http://example.com/image/dlcf_06in05.png">
<meta property="og:image" content="http://example.com/image/dlcf_06in06.png">
<meta property="og:image" content="http://example.com/image/dlcf_06in07.png">
<meta property="article:published_time" content="2025-05-23T02:12:02.000Z">
<meta property="article:modified_time" content="2025-05-27T06:41:56.550Z">
<meta property="article:author" content="Wang Song">
<meta property="article:tag" content="Python, C++, robot, ros , opencv, target detection">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/dlcf_06in01.png">

<link rel="canonical" href="http://example.com/2025/05/23/fastaichapter6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>fastaichapter6 | WangSong's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="WangSong's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WangSong's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/SongSop" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/23/fastaichapter6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Song">
      <meta itemprop="description" content="a graduate student working at Huzhou institute of Zhejiang University">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangSong's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          fastaichapter6
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-23 10:12:02" itemprop="dateCreated datePublished" datetime="2025-05-23T10:12:02+08:00">2025-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-27 14:41:56" itemprop="dateModified" datetime="2025-05-27T14:41:56+08:00">2025-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="其他计算机视觉问题"><a href="#其他计算机视觉问题" class="headerlink" title="其他计算机视觉问题"></a>其他计算机视觉问题</h1><p>上一章学习了实践中训练模型的一些基本技术，例如：学习率和周期律的选择。这一章我们需要深入学习其他两种机器视觉问题。</p>
<ul>
<li><p>多标签分类：发生在你想要预测每个图像的多个标签（有时甚至没有标签）</p>
</li>
<li><p>回归： 你的标签是一个或多个数字——数量而不是类别。</p>
</li>
</ul>
<p>这需要深入学习：输出激活，目标和损失函数。</p>
<h1 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h1><p><em>多标签分类</em>指的是识别图像中可能不只包含一种对象类别的问题。可能有多种对象，或者在你寻找的类别中根本没有对象。</p>
<p>tip:模型架构与前一章没有大改变，只有损失函数改变了。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>对于我们的示例，我们将使用 PASCAL 数据集，该数据集中的每个图像可以有多种分类对象。</p>
<p>我们首先按照通常的方式下载和提取数据集：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastai.vision.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">path = untar_data(URLs.PASCAL_2007)</span><br></pre></td></tr></table></figure>
<p>这个数据集与我们之前看到的不同，它不是按文件名或文件夹结构化的，而是附带一个 CSV 文件，告诉我们每个图像要使用的标签。我们可以通过将其读入 Pandas DataFrame 来检查 CSV 文件：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(path/<span class="string">&#x27;train.csv&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>文件名</th>
<th>标签</th>
<th>是否有效</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000005.jpg</td>
<td>椅子</td>
<td>True</td>
</tr>
<tr>
<td>1</td>
<td>000007.jpg</td>
<td>汽车</td>
<td>True</td>
</tr>
<tr>
<td>2</td>
<td>000009.jpg</td>
<td>马 人</td>
<td>True</td>
</tr>
<tr>
<td>3</td>
<td>000012.jpg</td>
<td>汽车</td>
<td>False</td>
</tr>
<tr>
<td>4</td>
<td>000016.jpg</td>
<td>自行车</td>
<td>True</td>
</tr>
</tbody>
</table>
</div>
<p>正如你所看到的，每个图像中的类别列表显示为一个以空格分隔的字符串。</p>
<p>既然我们已经看到了数据的样子，让我们准备好进行模型训练。</p>
<h2 id="构建数据块"><a href="#构建数据块" class="headerlink" title="构建数据块"></a>构建数据块</h2><p>将<code>DataFrame</code>对象转换为<code>DataLoaders</code>对象:使用数据块API 来创建<code>DataLoaders</code>对象，因为它提供了灵活性和简单性的良好组合。</p>
<p>以该数据集为例，展示使用数据块 API 构建<code>DataLoaders</code>对象的实践步骤。</p>
<p><code>数据集</code></p>
<p>返回单个项目的独立变量和依赖变量的元组的集合</p>
<p><code>数据加载器</code></p>
<p>提供一系列小批量的迭代器，其中每个小批量是一批独立变量和一批因变量的组合</p>
<p>除此之外，fastai 还提供了两个类来将您的训练和验证集合在一起：</p>
<p><code>Datasets</code></p>
<p>包含一个训练<code>Dataset</code>和一个验证<code>Dataset</code>的迭代器</p>
<p><code>DataLoaders</code></p>
<p>包含一个训练<code>DataLoader</code>和一个验证<code>DataLoader</code>的对象</p>
<p>由于<code>DataLoader</code>是建立在<code>Dataset</code>之上并为其添加附加功能（将多个项目整合成一个小批量），通常最容易的方法是首先创建和测试<code>Datasets</code>，然后再查看<code>DataLoaders</code>。</p>
<p>当我们创建<code>DataBlock</code>时，我们逐步逐步构建，并使用笔记本检查我们的数据。这是一个很好的方式，可以确保您在编码时保持动力，并留意任何问题。易于调试，因为您知道如果出现问题，它就在您刚刚输入的代码行中！</p>
<p>让我们从没有参数创建的数据块开始，这是最简单的情况：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dblock = DataBlock()</span><br></pre></td></tr></table></figure></p>
<p>我们可以从中创建一个<code>Datasets</code>对象。唯一需要的是一个源——在这种情况下是我们的 DataFrame：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsets = dblock.datasets(df)</span><br></pre></td></tr></table></figure>
<p>这包含一个<code>train</code>和一个<code>valid</code>数据集，我们可以对其进行索引：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsets.train[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(fname       <span class="number">008663.j</span>pg</span><br><span class="line"> labels      car person</span><br><span class="line"> is_valid    <span class="literal">False</span></span><br><span class="line"> Name: <span class="number">4346</span>, dtype: <span class="built_in">object</span>,</span><br><span class="line"> fname       <span class="number">008663.j</span>pg</span><br><span class="line"> labels      car person</span><br><span class="line"> is_valid    <span class="literal">False</span></span><br><span class="line"> Name: <span class="number">4346</span>, dtype: <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，这只是简单地两次返回 DataFrame 的一行。这是因为默认情况下，数据块假定我们有两个东西：输入和目标。我们需要从 DataFrame 中获取适当的字段，可以通过传递<code>get_x</code>和<code>get_y</code>函数来实现：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dblock = DataBlock(get_x = <span class="keyword">lambda</span> r: r[<span class="string">&#x27;fname&#x27;</span>], get_y = <span class="keyword">lambda</span> r: r[<span class="string">&#x27;labels&#x27;</span>])</span><br><span class="line">dsets = dblock.datasets(df)</span><br><span class="line">dsets.train[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;005620.jpg&#x27;</span>, <span class="string">&#x27;aeroplane&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，我们并没有以通常的方式定义函数，而是使用了 Python 的<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python-lambda.html">lambda</a>关键字。这只是定义并引用函数的一种快捷方式。以下更冗长的方法是相同的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_x</span>(<span class="params">r</span>): <span class="keyword">return</span> r[<span class="string">&#x27;fname&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_y</span>(<span class="params">r</span>): <span class="keyword">return</span> r[<span class="string">&#x27;labels&#x27;</span>]</span><br><span class="line">dblock = DataBlock(get_x = get_x, get_y = get_y)</span><br><span class="line">dsets = dblock.datasets(df)</span><br><span class="line">dsets.train[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;002549.jpg&#x27;</span>, <span class="string">&#x27;tvmonitor&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>tip:Lambda 函数非常适合快速迭代，但不兼容序列化，因此我们建议您在训练后要导出您的<code>Learner</code>时使用更冗长的方法（如果您只是在尝试实验，lambda 是可以的）。</p>
<p>我们可以看到独立变量需要转换为完整路径，以便我们可以将其作为图像打开，而因变量需要根据空格字符（这是 Python 的<code>split</code>函数的默认值）进行拆分，以便它变成一个列表：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_x</span>(<span class="params">r</span>): <span class="keyword">return</span> path/<span class="string">&#x27;train&#x27;</span>/r[<span class="string">&#x27;fname&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_y</span>(<span class="params">r</span>): <span class="keyword">return</span> r[<span class="string">&#x27;labels&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">dblock = DataBlock(get_x = get_x, get_y = get_y)</span><br><span class="line">dsets = dblock.datasets(df)</span><br><span class="line">dsets.train[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Path(<span class="string">&#x27;/home/sgugger/.fastai/data/pascal_2007/train/008663.jpg&#x27;</span>),</span><br><span class="line"> [<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;person&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>要实际打开图像并将其转换为张量，我们需要使用一组转换；块类型将为我们提供这些。我们可以使用先前使用过的相同块类型，只有一个例外：<code>ImageBlock</code>将再次正常工作，因为我们有一个指向有效图像的路径，但<code>CategoryBlock</code>不会起作用。问题在于该块返回一个单个整数，但我们需要为每个项目有多个标签。为了解决这个问题，我们使用<code>MultiCategoryBlock</code>。这种类型的块期望接收一个字符串列表，就像我们在这种情况下所做的那样，所以让我们来测试一下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dblock = DataBlock(blocks=(ImageBlock, MultiCategoryBlock),</span><br><span class="line">                   get_x = get_x, get_y = get_y)</span><br><span class="line">dsets = dblock.datasets(df)</span><br><span class="line">dsets.train[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(PILImage mode=RGB size=500x375,</span><br><span class="line"> TensorMultiCategory([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line"> &gt; <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]))</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，我们的类别列表的编码方式与常规的<code>CategoryBlock</code>不同。在那种情况下，我们有一个整数表示哪个类别存在，基于它在我们的词汇表中的位置。然而，在这种情况下，我们有一系列 0，其中任何位置上有一个 1 表示该类别存在。例如，如果第二和第四位置上有一个 1，那意味着词汇项二和四在这个图像中存在。这被称为<em>独热编码</em>。我们不能简单地使用类别索引列表的原因是每个列表的长度都不同，而 PyTorch 需要张量，其中所有内容必须是相同长度。</p>
<h1 id="专业术语：-独热编码"><a href="#专业术语：-独热编码" class="headerlink" title="专业术语： 独热编码"></a>专业术语： 独热编码</h1><p>使用一个 0 向量，其中每个位置都表示数据中表示的位置，以编码一个整数列表。</p>
<p>使用<code>torch.where</code>函数表明这个例子中的类代表什么。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idxs = torch.where(dsets.train[<span class="number">0</span>][<span class="number">1</span>]==<span class="number">1.</span>)[<span class="number">0</span>]</span><br><span class="line">dsets.train.vocab[idxs]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment">#1) [&#x27;dog&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>使用 NumPy 数组、PyTorch 张量和 fastai 的<code>L</code>类，我们可以直接使用列表或向量进行索引，这使得很多代码（比如这个例子）更清晰、更简洁。</p>
<p>到目前为止，我们忽略了列<code>is_valid</code>，这意味着<code>DataBlock</code>一直在使用默认的随机拆分。要明确选择我们验证集的元素，我们需要编写一个函数并将其传递给<code>splitter</code>（或使用 fastai 的预定义函数或类之一）。它将获取项目（这里是我们整个 DataFrame）并必须返回两个（或更多）整数列表：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">splitter</span>(<span class="params">df</span>):</span><br><span class="line">    train = df.index[~df[<span class="string">&#x27;is_valid&#x27;</span>]].tolist()</span><br><span class="line">    valid = df.index[df[<span class="string">&#x27;is_valid&#x27;</span>]].tolist()</span><br><span class="line">    <span class="keyword">return</span> train,valid</span><br><span class="line"></span><br><span class="line">dblock = DataBlock(blocks=(ImageBlock, MultiCategoryBlock),</span><br><span class="line">                   splitter=splitter,</span><br><span class="line">                   get_x=get_x,</span><br><span class="line">                   get_y=get_y)</span><br><span class="line"></span><br><span class="line">dsets = dblock.datasets(df)</span><br><span class="line">dsets.train[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(PILImage mode=RGB size=500x333,</span><br><span class="line"> TensorMultiCategory([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line"> &gt; <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]))</span><br></pre></td></tr></table></figure>
<p>正如我们讨论过的，<code>DataLoader</code>将<code>Dataset</code>中的项目整理成一个小批量。这是一个张量的元组，其中每个张量简单地堆叠了<code>Dataset</code>项目中该位置的项目。</p>
<p>现在我们已经确认了单个项目看起来没问题，还有一步，我们需要确保我们可以创建我们的<code>DataLoaders</code>，即确保每个项目的大小相同。为了做到这一点，我们可以使用<code>RandomResizedCrop</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dblock = DataBlock(blocks=(ImageBlock, MultiCategoryBlock),</span><br><span class="line">                   splitter=splitter,</span><br><span class="line">                   get_x=get_x,</span><br><span class="line">                   get_y=get_y,</span><br><span class="line">                   item_tfms = RandomResizedCrop(<span class="number">128</span>, min_scale=<span class="number">0.35</span>))</span><br><span class="line">dls = dblock.dataloaders(df)</span><br></pre></td></tr></table></figure>
<p>现在我们可以显示我们数据的一个样本：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dls.show_batch(nrows=<span class="number">1</span>, ncols=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/dlcf_06in01.png" alt=""></p>
<p>请记住，如果在从<code>DataBlock</code>创建<code>DataLoaders</code>时出现任何问题，或者如果您想查看<code>DataBlock</code>的确切情况，您可以使用我们在上一章中介绍的<code>summary</code>方法。</p>
<p>我们的数据现在已经准备好用于训练模型。正如我们将看到的，当我们创建我们的<code>Learner</code>时，没有任何变化，但在幕后，fastai 库将为我们选择一个新的损失函数：二元交叉熵。</p>
<h2 id="二元交叉熵"><a href="#二元交叉熵" class="headerlink" title="二元交叉熵"></a>二元交叉熵</h2><p>创建<code>Learner</code>时其分为四部分：模型，<code>DataLoaders</code>对象，优化器和要使用的损失函数。</p>
<p>本次我们已经构建好了<code>DataLoaders</code>，利用fastai的<code>resnet</code>模型，创建一个<code>SGD</code>优化器，在这章中我们专注于创建一个适合的损失函数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learn = cnn_learner(dls, resnet18)</span><br></pre></td></tr></table></figure>
<p><code>Learner</code>中的模型通常是从<code>nn.Module</code>继承的类的对象，并且我们可以使用括号调用它，它将返回模型的激活。你应该将独立变量作为一个小批量传递给它。我们可以尝试从我们的<code>DataLoader</code>中获取一个小批量，然后将其传递给模型：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,y = dls.train.one_batch()</span><br><span class="line">activs = learn.model(x)</span><br><span class="line">activs.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">64</span>, <span class="number">20</span>])</span><br></pre></td></tr></table></figure>
<p>批量大小为 64，我们需要计算 20 个类别中的每一个的概率。其中一个激活的样子如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([ <span class="number">2.0258</span>, -<span class="number">1.3543</span>,  <span class="number">1.4640</span>,  <span class="number">1.7754</span>, -<span class="number">1.2820</span>, -<span class="number">5.8053</span>,  <span class="number">3.6130</span>,  <span class="number">0.7193</span>,</span><br><span class="line"> &gt; -<span class="number">4.3683</span>, -<span class="number">2.5001</span>, -<span class="number">2.8373</span>, -<span class="number">1.8037</span>,  <span class="number">2.0122</span>,  <span class="number">0.6189</span>,  <span class="number">1.9729</span>,  <span class="number">0.8999</span>,</span><br><span class="line"> &gt; -<span class="number">2.6769</span>, -<span class="number">0.3829</span>,  <span class="number">1.2212</span>,  <span class="number">1.6073</span>],</span><br><span class="line">       device=<span class="string">&#x27;cuda:0&#x27;</span>, grad_fn=&lt;SelectBackward&gt;)</span><br></pre></td></tr></table></figure>
<h1 id="获取模型激活"><a href="#获取模型激活" class="headerlink" title="获取模型激活"></a>获取模型激活</h1><p>手动获取一个小批量并将其传递到模型中，并查看激活和损失，对于调试模型非常重要。这对学习也非常有帮助，这样你就可以清楚地看到发生了什么。</p>
<p>它们还没有缩放到 0 到 1 之间，但我们学会了如何在第四章中使用<code>sigmoid</code>函数来做到这一点。我们还看到了如何基于此计算损失——这是我们在第四章中的损失函数，加上了在前一章中讨论的<code>log</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_cross_entropy</span>(<span class="params">inputs, targets</span>):</span><br><span class="line">    inputs = inputs.sigmoid()</span><br><span class="line">    <span class="keyword">return</span> -torch.where(targets==<span class="number">1</span>, inputs, <span class="number">1</span>-inputs).log().mean()</span><br></pre></td></tr></table></figure>
<p>请注意，由于我们有一个独热编码的因变量，我们不能直接使用<code>nll_loss</code>或<code>softmax</code>（因此我们不能使用<code>cross_entropy</code>）：</p>
<ul>
<li><p>正如我们所看到的，<code>softmax</code>要求所有预测总和为 1，并且倾向于使一个激活远远大于其他激活（因为使用了<code>exp</code>）；然而，我们可能有多个我们确信出现在图像中的对象，因此限制激活的最大总和为 1 并不是一个好主意。出于同样的原因，如果我们认为<em>任何</em>类别都不出现在图像中，我们可能希望总和<em>小于</em>1。</p>
</li>
<li><p>正如我们所看到的，<code>nll_loss</code>返回的是一个激活值：与项目的单个标签对应的单个激活值。当我们有多个标签时，这是没有意义的。</p>
</li>
</ul>
<p>另一方面，<code>binary_cross_entropy</code>函数，即<code>mnist_loss</code>加上<code>log</code>，正是我们所需要的，这要归功于 PyTorch 的逐元素操作的魔力。每个激活将与每个列的每个目标进行比较，因此我们不必做任何事情使此函数适用于多个列。</p>
<h1 id="Jeremy-Says"><a href="#Jeremy-Says" class="headerlink" title="Jeremy Says"></a>Jeremy Says</h1><p>我真的很喜欢使用像 PyTorch 这样的库，具有广播和逐元素操作，因为我经常发现我可以编写的代码同样适用于单个项目或一批项目，而无需更改。<code>binary_cross_entropy</code>就是一个很好的例子。通过使用这些操作，我们不必自己编写循环，可以依赖 PyTorch 根据我们正在处理的张量的秩适当地执行我们需要的循环。</p>
<p>PyTorch 已经为我们提供了这个函数。实际上，它提供了许多版本，名称相当令人困惑！</p>
<p><code>F.binary_cross_entropy</code>及其模块等效<code>nn.BCELoss</code>计算一个独热编码目标的交叉熵，但不包括初始的<code>sigmoid</code>。通常，对于独热编码目标，您将希望使用<code>F.binary_cross_entropy_with_logits</code>（或<code>nn.BCEWithLogitsLoss</code>），它们在一个函数中同时执行 sigmoid 和二元交叉熵，就像前面的例子一样。</p>
<p>对于单标签数据集（如 MNIST 或 Pet 数据集），其中目标被编码为单个整数，相应的是<code>F.nll_loss</code>或<code>nn.NLLLoss</code>（没有初始 softmax 的版本），以及<code>F.cross_entropy</code>或<code>nn.CrossEntropyLoss</code>（具有初始 softmax 的版本）。</p>
<p>由于我们有一个独热编码的目标，我们将使用<code>BCEWithLogitsLoss</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss_func = nn.BCEWithLogitsLoss()</span><br><span class="line">loss = loss_func(activs, y)</span><br><span class="line">loss</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="number">1.0082</span>, device=<span class="string">&#x27;cuda:5&#x27;</span>, grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward&gt;)</span><br></pre></td></tr></table></figure>
<p>我们不需要告诉 fastai 使用这个损失函数（尽管如果我们想要的话可以这样做），因为它将自动为我们选择。fastai 知道<code>DataLoaders</code>具有多个类别标签，因此默认情况下将使用<code>nn.BCEWithLogitsLoss</code>。</p>
<p>与前一章相比的一个变化是我们使用的指标：因为这是一个多标签问题，我们不能使用准确度函数。为什么呢？嗯，准确度是这样比较我们的输出和我们的目标的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">inp, targ, axis=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;Compute accuracy with `targ` when `pred` is bs * n_classes&quot;</span></span><br><span class="line">    pred = inp.argmax(dim=axis)</span><br><span class="line">    <span class="keyword">return</span> (pred == targ).<span class="built_in">float</span>().mean()</span><br></pre></td></tr></table></figure>
<p>预测的类是具有最高激活的类（这就是<code>argmax</code>的作用）。这里不起作用，因为我们可能在单个图像上有多个预测。在对我们的激活应用 sigmoid（使它们在 0 和 1 之间）之后，我们需要通过选择<em>阈值</em>来决定哪些是 0，哪些是 1。高于阈值的每个值将被视为 1，低于阈值的每个值将被视为 0：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy_multi</span>(<span class="params">inp, targ, thresh=<span class="number">0.5</span>, sigmoid=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;Compute accuracy when `inp` and `targ` are the same size.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> sigmoid: inp = inp.sigmoid()</span><br><span class="line">    <span class="keyword">return</span> ((inp&gt;thresh)==targ.<span class="built_in">bool</span>()).<span class="built_in">float</span>().mean()</span><br></pre></td></tr></table></figure>
<p>如果我们直接将<code>accuracy_multi</code>作为指标传递，它将使用<code>threshold</code>的默认值，即 0.5。我们可能希望调整该默认值并创建一个具有不同默认值的新版本的<code>accuracy_multi</code>。为了帮助解决这个问题，Python 中有一个名为<code>partial</code>的函数。它允许我们<em>绑定</em>一个带有一些参数或关键字参数的函数，从而创建该函数的新版本，每当调用它时，总是包含这些参数。例如，这里是一个接受两个参数的简单函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name, say_what=<span class="string">&quot;Hello&quot;</span></span>): <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;say_what&#125;</span> <span class="subst">&#123;name&#125;</span>.&quot;</span></span><br><span class="line">say_hello(<span class="string">&#x27;Jeremy&#x27;</span>),say_hello(<span class="string">&#x27;Jeremy&#x27;</span>, <span class="string">&#x27;Ahoy!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;Hello Jeremy.&#x27;</span>, <span class="string">&#x27;Ahoy! Jeremy.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-partial.html">partial</a>切换到该函数的法语版本：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = partial(say_hello, say_what=<span class="string">&quot;Bonjour&quot;</span>)</span><br><span class="line">f(<span class="string">&quot;Jeremy&quot;</span>),f(<span class="string">&quot;Sylvain&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;Bonjour Jeremy.&#x27;</span>, <span class="string">&#x27;Bonjour Sylvain.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们可以训练我们的模型。让我们尝试将准确度阈值设置为 0.2 作为我们的指标：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">learn = cnn_learner(dls, resnet50, metrics=partial(accuracy_multi, thresh=<span class="number">0.2</span>))</span><br><span class="line">learn.fine_tune(<span class="number">3</span>, base_lr=<span class="number">3e-3</span>, freeze_epochs=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>epoch</th>
<th>train_loss</th>
<th>valid_loss</th>
<th>accuracy_multi</th>
<th>time</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0.903610</td>
<td>0.659728</td>
<td>0.263068</td>
<td>00:07</td>
</tr>
<tr>
<td>1</td>
<td>0.724266</td>
<td>0.346332</td>
<td>0.525458</td>
<td>00:07</td>
</tr>
<tr>
<td>2</td>
<td>0.415597</td>
<td>0.125662</td>
<td>0.937590</td>
<td>00:07</td>
</tr>
<tr>
<td>3</td>
<td>0.254987</td>
<td>0.116880</td>
<td>0.945418</td>
<td>00:07</td>
</tr>
<tr>
<td>epoch</td>
<td>train_loss</td>
<td>valid_loss</td>
<td>accuracy_multi</td>
<td>time</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>0</td>
<td>0.123872</td>
<td>0.132634</td>
<td>0.940179</td>
<td>00:08</td>
</tr>
<tr>
<td>1</td>
<td>0.112387</td>
<td>0.113758</td>
<td>0.949343</td>
<td>00:08</td>
</tr>
<tr>
<td>2</td>
<td>0.092151</td>
<td>0.104368</td>
<td>0.951195</td>
<td>00:08</td>
</tr>
</tbody>
</table>
</div>
<p>选择阈值很重要。如果选择的阈值太低，通常会选择错误标记的对象。我们可以通过改变我们的度量标准然后调用<code>validate</code>来看到这一点，它会返回验证损失和度量标准：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">learn.metrics = partial(accuracy_multi, thresh=<span class="number">0.1</span>)</span><br><span class="line">learn.validate()</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment">#2) [0.10436797887086868,0.93057781457901]</span></span><br></pre></td></tr></table></figure>
<p>如果选择的阈值太高，将只选择模型非常有信心的对象：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">learn.metrics = partial(accuracy_multi, thresh=<span class="number">0.99</span>)</span><br><span class="line">learn.validate()</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment">#2) [0.10436797887086868,0.9416930675506592]</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过尝试几个级别并查看哪个效果最好来找到最佳阈值。如果我们只抓取一次预测，这将快得多：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preds,targs = learn.get_preds()</span><br></pre></td></tr></table></figure>
<p>然后我们可以直接调用度量标准。请注意，默认情况下，<code>get_preds</code>会为我们应用输出激活函数（在本例中为 sigmoid），因此我们需要告诉<code>accuracy_multi</code>不要应用它：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy_multi(preds, targs, thresh=<span class="number">0.9</span>, sigmoid=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TensorMultiCategory(<span class="number">0.9554</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用这种方法找到最佳阈值水平：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xs = torch.linspace(<span class="number">0.05</span>,<span class="number">0.95</span>,<span class="number">29</span>)</span><br><span class="line">accs = [accuracy_multi(preds, targs, thresh=i, sigmoid=<span class="literal">False</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xs]</span><br><span class="line">plt.plot(xs,accs);</span><br></pre></td></tr></table></figure>
<p><img src="/image/dlcf_06in02.png" alt=""></p>
<p>在这种情况下，我们使用验证集来选择一个超参数（阈值），这就是验证集的目的。有时学生们表达了他们的担忧，即我们可能会对验证集<em>过拟合</em>，因为我们正在尝试很多值来找出哪个是最好的。然而，正如你在图中看到的，改变阈值在这种情况下会产生一个平滑的曲线，因此我们显然没有选择不合适的异常值。这是一个很好的例子，说明你必须小心理论（不要尝试很多超参数值，否则可能会过拟合验证集）与实践（如果关系是平滑的，这样做是可以的）之间的区别。</p>
<h1 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h1><p>很容易将深度学习模型视为被分类到领域中，如<em>计算机视觉</em>、<em>NLP</em>等等。事实上，这就是 fastai 对其应用程序进行分类的方式——主要是因为大多数人习惯于这样思考事物。</p>
<p>但实际上，这隐藏了一个更有趣和更深入的视角。一个模型由其独立和依赖变量以及其损失函数定义。这意味着实际上有比简单的基于领域的分割更广泛的模型数组。也许我们有一个独立变量是图像，一个依赖变量是文本（例如，从图像生成标题）；或者我们有一个独立变量是文本，一个依赖变量是图像（例如，从标题生成图像——这实际上是深度学习可以做到的！）；或者我们有图像、文本和表格数据作为独立变量，我们试图预测产品购买……可能性真的是无穷无尽的。</p>
<p>要能够超越固定应用程序，为新问题制定自己的新颖解决方案，真正理解数据块 API（也许还有我们将在本书后面看到的中间层 API）是有帮助的。举个例子，让我们考虑<em>图像回归</em>的问题。这指的是从一个独立变量是图像，依赖变量是一个或多个浮点数的数据集中学习。通常我们看到人们将图像回归视为一个完全独立的应用程序——但正如你在这里看到的，我们可以将其视为数据块 API 上的另一个 CNN。</p>
<p>我们将直接跳到图像回归的一个有点棘手的变体，因为我们知道你已经准备好了！我们将做一个关键点模型。<em>关键点</em>指的是图像中表示的特定位置——在这种情况下，我们将使用人物的图像，并且我们将寻找每个图像中人脸的中心。这意味着我们实际上将为每个图像预测<em>两个</em>值：人脸中心的行和列。</p>
<h2 id="数据组装"><a href="#数据组装" class="headerlink" title="数据组装"></a>数据组装</h2><p>我们将在这一部分使用<a target="_blank" rel="noopener" href="https://oreil.ly/-4cO-">Biwi Kinect Head Pose 数据集</a>。我们将像往常一样开始下载数据集：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = untar_data(URLs.BIWI_HEAD_POSE)</span><br></pre></td></tr></table></figure>
<p>让我们看看我们有什么！</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.ls()</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment">#50) [Path(&#x27;13.obj&#x27;),Path(&#x27;07.obj&#x27;),Path(&#x27;06.obj&#x27;),Path(&#x27;13&#x27;),Path(&#x27;10&#x27;),Path(&#x27;</span></span><br><span class="line"> &gt; 02<span class="string">&#x27;),Path(&#x27;</span><span class="number">11</span><span class="string">&#x27;),Path(&#x27;</span>01<span class="string">&#x27;),Path(&#x27;</span><span class="number">20.</span>obj<span class="string">&#x27;),Path(&#x27;</span><span class="number">17</span><span class="string">&#x27;)...]</span></span><br></pre></td></tr></table></figure>
<p>有 24 个从 01 到 24 编号的目录（它们对应不同的被摄人物），以及每个目录对应的<em>.obj</em>文件（我们这里不需要）。让我们看看其中一个目录的内容：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(path/<span class="string">&#x27;01&#x27;</span>).ls()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment">#1000) [Path(&#x27;01/frame_00281_pose.txt&#x27;),Path(&#x27;01/frame_00078_pose.txt&#x27;),Path(&#x27;0</span></span><br><span class="line"> &gt; <span class="number">1</span>/frame_00349_rgb.jpg<span class="string">&#x27;),Path(&#x27;</span>01/frame_00304_pose.txt<span class="string">&#x27;),Path(&#x27;</span>01/frame_00207_</span><br><span class="line"> &gt; pose.txt<span class="string">&#x27;),Path(&#x27;</span>01/frame_00116_rgb.jpg<span class="string">&#x27;),Path(&#x27;</span>01/frame_00084_rgb.jpg<span class="string">&#x27;),Path</span></span><br><span class="line"><span class="string"> &gt; (&#x27;</span>01/frame_00070_rgb.jpg<span class="string">&#x27;),Path(&#x27;</span>01/frame_00125_pose.txt<span class="string">&#x27;),Path(&#x27;</span>01/frame_003</span><br><span class="line"> &gt; 24_rgb.jpg<span class="string">&#x27;)...]</span></span><br></pre></td></tr></table></figure>
<p>在子目录中，我们有不同的帧。每个帧都带有一个图像（<em>_rgb.jpg</em>）和一个姿势文件（<em>_pose.txt</em>）。我们可以使用<code>get_image_files</code>轻松递归获取所有图像文件，然后编写一个函数，将图像文件名转换为其关联的姿势文件：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_files = get_image_files(path)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">img2pose</span>(<span class="params">x</span>): <span class="keyword">return</span> Path(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(x)[:-<span class="number">7</span>]&#125;</span>pose.txt&#x27;</span>)</span><br><span class="line">img2pose(img_files[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path(<span class="string">&#x27;13/frame_00349_pose.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>让我们来看看我们的第一张图片：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = PILImage.create(img_files[<span class="number">0</span>])</span><br><span class="line">im.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">480</span>, <span class="number">640</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im.to_thumb(<span class="number">160</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/dlcf_06in03.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="https://oreil.ly/wHL28">Biwi 数据集网站</a>用于解释与每个图像关联的姿势文本文件的格式，显示头部中心的位置。这些细节对我们来说并不重要，所以我们只会展示我们用来提取头部中心点的函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cal = np.genfromtxt(path/<span class="string">&#x27;01&#x27;</span>/<span class="string">&#x27;rgb.cal&#x27;</span>, skip_footer=<span class="number">6</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ctr</span>(<span class="params">f</span>):</span><br><span class="line">    ctr = np.genfromtxt(img2pose(f), skip_header=<span class="number">3</span>)</span><br><span class="line">    c1 = ctr[<span class="number">0</span>] * cal[<span class="number">0</span>][<span class="number">0</span>]/ctr[<span class="number">2</span>] + cal[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">    c2 = ctr[<span class="number">1</span>] * cal[<span class="number">1</span>][<span class="number">1</span>]/ctr[<span class="number">2</span>] + cal[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> tensor([c1,c2])</span><br></pre></td></tr></table></figure>
<p>这个函数将坐标作为两个项目的张量返回：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_ctr(img_files[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">384.6370</span>, <span class="number">259.4787</span>])</span><br></pre></td></tr></table></figure>
<p>我们可以将此函数传递给<code>DataBlock</code>作为<code>get_y</code>，因为它负责为每个项目标记。我们将将图像调整为其输入大小的一半，以加快训练速度。</p>
<p>一个重要的要点是我们不应该只使用随机分割器。在这个数据集中，同一个人出现在多个图像中，但我们希望确保我们的模型可以泛化到它尚未见过的人。数据集中的每个文件夹包含一个人的图像。因此，我们可以创建一个分割器函数，仅为一个人返回<code>True</code>，从而使验证集仅包含该人的图像。</p>
<p>与以前的数据块示例的唯一区别是第二个块是<code>PointBlock</code>。这是必要的，以便 fastai 知道标签代表坐标；这样，它就知道在进行数据增强时，应该对这些坐标执行与图像相同的增强：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">biwi = DataBlock(</span><br><span class="line">    blocks=(ImageBlock, PointBlock),</span><br><span class="line">    get_items=get_image_files,</span><br><span class="line">    get_y=get_ctr,</span><br><span class="line">    splitter=FuncSplitter(<span class="keyword">lambda</span> o: o.parent.name==<span class="string">&#x27;13&#x27;</span>),</span><br><span class="line">    batch_tfms=[*aug_transforms(size=(<span class="number">240</span>,<span class="number">320</span>)),</span><br><span class="line">                Normalize.from_stats(*imagenet_stats)]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="点和数据增强"><a href="#点和数据增强" class="headerlink" title="点和数据增强"></a>点和数据增强</h1><p>我们不知道其他库（除了 fastai）会自动且正确地将数据增强应用于坐标。因此，如果您使用另一个库，可能需要禁用这些问题的数据增强。</p>
<p>在进行任何建模之前，我们应该查看我们的数据以确认它看起来没问题：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dls = biwi.dataloaders(path)</span><br><span class="line">dls.show_batch(max_n=<span class="number">9</span>, figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p><img src="img/dlcf_06in04.png" alt=""></p>
<p>看起来不错！除了通过视觉查看批次外，还可以查看底层张量（尤其是作为学生；这将有助于澄清您对模型实际看到的内容的理解）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xb,yb = dls.one_batch()</span><br><span class="line">xb.shape,yb.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(torch.Size([<span class="number">64</span>, <span class="number">3</span>, <span class="number">240</span>, <span class="number">320</span>]), torch.Size([<span class="number">64</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<p>确保您了解为什么这些是我们小批量的形状。</p>
<p>这是依赖变量的一个示例行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yb[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0.0111</span>, <span class="number">0.1810</span>]], device=<span class="string">&#x27;cuda:5&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，我们不必使用单独的<em>图像回归</em>应用程序；我们所要做的就是标记数据并告诉 fastai 独立变量和因变量代表什么类型的数据。</p>
<p>创建我们的<code>Learner</code>也是一样的。我们将使用与之前相同的函数，只有一个新参数，然后我们就可以准备训练我们的模型了。</p>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>像往常一样，我们可以使用<code>cnn_learner</code>来创建我们的<code>Learner</code>。还记得在第一章中我们如何使用<code>y_range</code>告诉 fastai 我们目标的范围吗？我们将在这里做同样的事情（fastai 和 PyTorch 中的坐标始终在-1 和+1 之间重新缩放）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learn = cnn_learner(dls, resnet18, y_range=(-<span class="number">1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><code>y_range</code>在 fastai 中使用<code>sigmoid_range</code>实现，其定义如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid_range</span>(<span class="params">x, lo, hi</span>): <span class="keyword">return</span> torch.sigmoid(x) * (hi-lo) + lo</span><br></pre></td></tr></table></figure>
<p>如果定义了<code>y_range</code>，则将其设置为模型的最终层。花点时间思考一下这个函数的作用，以及为什么它强制模型在范围<code>(lo,hi)</code>内输出激活。</p>
<p>这是它的样子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_function(partial(sigmoid_range,lo=-<span class="number">1</span>,hi=<span class="number">1</span>), <span class="built_in">min</span>=-<span class="number">4</span>, <span class="built_in">max</span>=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/dlcf_06in05.png" alt=""></p>
<p>我们没有指定损失函数，这意味着我们得到了 fastai 选择的默认值。让我们看看它为我们选择了什么：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dls.loss_func</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlattenedLoss of MSELoss()</span><br></pre></td></tr></table></figure>
<p>这是有道理的，因为当坐标被用作因变量时，大多数情况下我们可能会尽可能地预测接近某个值；这基本上就是 <code>MSELoss</code>（均方误差损失）所做的。如果你想使用不同的损失函数，你可以通过使用 <code>loss_func</code> 参数将其传递给 <code>cnn_learner</code>。</p>
<p>还要注意，我们没有指定任何指标。这是因为均方误差已经是这个任务的一个有用指标（尽管在我们取平方根之后可能更易解释）。</p>
<p>我们可以使用学习率查找器选择一个好的学习率：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learn.lr_find()</span><br></pre></td></tr></table></figure>
<p><img src="/image/dlcf_06in06.png" alt=""></p>
<p>我们将尝试一个学习率为 2e-2：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">2e-2</span></span><br><span class="line">learn.fit_one_cycle(<span class="number">5</span>, lr)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>epoch</th>
<th>train_loss</th>
<th>valid_loss</th>
<th>time</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0.045840</td>
<td>0.012957</td>
<td>00:36</td>
</tr>
<tr>
<td>1</td>
<td>0.006369</td>
<td>0.001853</td>
<td>00:36</td>
</tr>
<tr>
<td>2</td>
<td>0.003000</td>
<td>0.000496</td>
<td>00:37</td>
</tr>
<tr>
<td>3</td>
<td>0.001963</td>
<td>0.000360</td>
<td>00:37</td>
</tr>
<tr>
<td>4</td>
<td>0.001584</td>
<td>0.000116</td>
<td>00:36</td>
</tr>
</tbody>
</table>
</div>
<p>通常情况下，当我们运行这个时，我们得到的损失大约是 0.0001，这对应于这个平均坐标预测误差：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.sqrt(<span class="number">0.0001</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.01</span></span><br></pre></td></tr></table></figure>
<p>这听起来非常准确！但是重要的是要用 <code>Learner.show_results</code> 查看我们的结果。左侧是实际（<em>真实</em>）坐标，右侧是我们模型的预测：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learn.show_results(ds_idx=<span class="number">1</span>, max_n=<span class="number">3</span>, figsize=(<span class="number">6</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/image/dlcf_06in07.png" alt=""></p>
<p>令人惊讶的是，仅仅几分钟的计算，我们就创建了一个如此准确的关键点模型，而且没有任何特定领域的应用。这就是在灵活的 API 上构建并使用迁移学习的力量！特别引人注目的是，我们能够如此有效地使用迁移学习，即使在完全不同的任务之间；我们的预训练模型是用来进行图像分类的，而我们对图像回归进行了微调。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在乍一看完全不同的问题（单标签分类、多标签分类和回归）中，我们最终使用相同的模型，只是输出的数量不同。唯一改变的是损失函数，这就是为什么重要的是要仔细检查你是否为你的问题使用了正确的损失函数。</p>
<p>fastai 将自动尝试从您构建的数据中选择正确的损失函数，但如果您使用纯 PyTorch 构建您的 <code>DataLoader</code>，请确保您认真考虑您选择的损失函数，并记住您很可能想要以下内容：</p>
<ul>
<li><p><code>nn.CrossEntropyLoss</code> 用于单标签分类</p>
</li>
<li><p><code>nn.BCEWithLogitsLoss</code> 用于多标签分类</p>
</li>
<li><p><code>nn.MSELoss</code> 用于回归</p>
</li>
</ul>
<h1 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h1><ol>
<li>多标签分类如何提高熊分类器的可用性？</li>
</ol>
<ul>
<li>当图片名中没有熊或是出现的不是熊时他能够进行辨别</li>
</ul>
<ol>
<li>在多标签分类问题中，我们如何对因变量进行编码？</li>
</ol>
<ul>
<li>因变量需要根据空格字符（这是 Python 的<code>split</code>函数的默认值）进行拆分，以便它变成一个列表</li>
</ul>
<ol>
<li>如何访问 DataFrame 的行和列，就像它是一个矩阵一样？</li>
</ol>
<ul>
<li>访问 DataFrame 行和列：使用 iloc 按整数位置或 loc 按标签索引（如 df.iloc[行,列] 或 df.loc[行标签,列标签]）。</li>
</ul>
<ol>
<li>如何从 DataFrame 中按名称获取列？</li>
</ol>
<ul>
<li>按名称获取列：通过 df[“列名”] 获取单列（Series），或 df[[“列名”]] 保持 DataFrame 结构，列名特殊时用方括号。</li>
</ul>
<ol>
<li><code>Dataset</code> 和 <code>DataLoader</code> 之间有什么区别？</li>
</ol>
<ul>
<li>由于<code>DataLoader</code>是建立在<code>Dataset</code>之上并为其添加附加功能（将多个项目整合成一个小批量），通常最容易的方法是首先创建和测试<code>Datasets</code>，然后再查看<code>DataLoaders</code>。</li>
</ul>
<ol>
<li><code>Datasets</code> 对象通常包含什么？</li>
</ol>
<ul>
<li>包含一个训练<code>Dataset</code>和一个验证<code>Dataset</code>的迭代器</li>
</ul>
<ol>
<li><code>DataLoaders</code> 对象通常包含什么？</li>
</ol>
<ul>
<li>包含一个训练<code>DataLoader</code>和一个验证<code>DataLoader</code>的对象</li>
</ul>
<ol>
<li><code>lambda</code> 在 Python 中是做什么的？</li>
</ol>
<ul>
<li>这只是定义并引用函数的一种快捷方式</li>
</ul>
<ol>
<li>如何使用数据块 API 自定义独立变量和因变量的创建方法？</li>
</ol>
<ul>
<li>使用数据块 API 时，通过 get_x 和 get_y 参数分别定义处理输入（独立变量）和输出（因变量）的自定义方法，例如：<br>DataBlock(get_x=自定义函数, get_y=自定义函数)。</li>
</ul>
<ol>
<li>当使用一个独热编码的目标时，为什么 softmax 不是一个合适的输出激活函数？</li>
</ol>
<ul>
<li>因为所有类别概率总和并不为1</li>
</ul>
<ol>
<li>当使用一个独热编码的目标时，为什么 <code>nll_loss</code> 不是一个合适的损失函数？</li>
</ol>
<ul>
<li><code>nll_loss</code>返回的是一个激活值：与项目的单个标签对应的单个激活值。当我们有多个标签时，这是没有意义的。</li>
</ul>
<ol>
<li><code>nn.BCELoss</code> 和 <code>nn.BCEWithLogitsLoss</code> 之间有什么区别？</li>
</ol>
<ul>
<li><p><code>nn.BCELoss</code>计算一个独热编码目标的交叉熵，但不包括初始的<code>sigmoid</code>。</p>
</li>
<li><p><code>nn.BCEWithLogitsLoss</code>它在一个函数中同时执行 sigmoid 和二元交叉熵，就像前面的例子一样。</p>
</li>
</ul>
<ol>
<li>为什么在多标签问题中不能使用常规准确率？</li>
</ol>
<ul>
<li>在多标签问题中，常规准确率要求 所有标签完全正确匹配，而实际场景中部分标签预测正确即可有效，导致常规准确率过于严格且无法反映模型部分预测的有效性。</li>
</ul>
<ol>
<li>何时可以在验证集上调整超参数？</li>
</ol>
<ul>
<li>在验证集上调整超参数是标准做法，但需确保 测试集完全独立且仅用于最终评估，避免调整过程中信息泄漏导致过拟合和评估偏差。</li>
</ul>
<ol>
<li><code>y_range</code> 在 fastai 中是如何实现的？（看看你是否可以自己实现并在不偷看的情况下测试！）</li>
</ol>
<ul>
<li>在 fastai 中，y_range 通过 在模型输出层添加 Sigmoid 激活函数并线性缩放到指定范围 实现，适用于回归任务以约束预测值的合理区间（如 (a, b)）。</li>
</ul>
<ol>
<li>回归问题是什么？对于这样的问题应该使用什么损失函数？</li>
</ol>
<ul>
<li>回归问题是预测连续数值的任务（如价格、温度），常用 均方误差（MSE） 或 平均绝对误差（MAE） 作为损失函数，其中 MSE 是最基础且广泛使用的选择。</li>
</ul>
<ol>
<li>为了确保 fastai 库将相同的数据增强应用于您的输入图像和目标点坐标，您需要做什么？</li>
</ol>
<ul>
<li>使用PointBlock并将空间变换（如翻转、旋转）添加到item_tfms，同时确保目标点坐标已归一化，即可使fastai对图像和坐标同步应用相同数据增强。</li>
</ul>
<h2 id="进一步研究"><a href="#进一步研究" class="headerlink" title="进一步研究"></a>进一步研究</h2><ol>
<li><p>阅读关于 Pandas DataFrames 的教程，并尝试一些看起来有趣的方法。查看书籍网站上推荐的教程。</p>
</li>
<li><p>使用多标签分类重新训练熊分类器。看看你是否可以使其有效地处理不包含任何熊的图像，包括在 Web 应用程序中显示该信息。尝试一张包含两种熊的图像。检查在单标签数据集上使用多标签分类是否会影响准确性。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/05/13/fastaichapter5/" rel="prev" title="fastaichapter5">
      <i class="fa fa-chevron-left"></i> fastaichapter5
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/05/27/%E5%82%BB%E5%AD%90%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81/" rel="next" title="傻子如何写代码">
      傻子如何写代码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">其他计算机视觉问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">多标签分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-number">2.2.</span> <span class="nav-text">构建数据块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%EF%BC%9A-%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">专业术语： 独热编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E4%BA%A4%E5%8F%89%E7%86%B5"><span class="nav-number">3.1.</span> <span class="nav-text">二元交叉熵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9E%8B%E6%BF%80%E6%B4%BB"><span class="nav-number">4.</span> <span class="nav-text">获取模型激活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jeremy-Says"><span class="nav-number">5.</span> <span class="nav-text">Jeremy Says</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E5%BD%92"><span class="nav-number">6.</span> <span class="nav-text">回归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E8%A3%85"><span class="nav-number">6.1.</span> <span class="nav-text">数据组装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%82%B9%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA"><span class="nav-number">7.</span> <span class="nav-text">点和数据增强</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">训练模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">8.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E5%90%8E%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">课后题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%A0%94%E7%A9%B6"><span class="nav-number">9.1.</span> <span class="nav-text">进一步研究</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Song"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Wang Song</p>
  <div class="site-description" itemprop="description">a graduate student working at Huzhou institute of Zhejiang University</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SongSop" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SongSop" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3042903197@qq.com" title="E-Mail → mailto:3042903197@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Song</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
